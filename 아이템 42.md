---
tags:
  - study
  - 이펙티브자바
title: 익명 클래스보다는 람다를 사용하라
chapter: 아이템 42
---
## 익명 클래스보다는 람다를 사용하라

### 핵심
- 자바 8이되면서 작은 함수 객체를 구현하는데 적합한 람다가 도입되었다.
- 익명 클래스는 (함수형 인터페이스가 아닌) 타입의 인스턴스를 만들때만 사용하라
- 람다는 작은 함수 객체를 아주 쉽게 표현할 수 있어 (이전 자바에서는 실용적이지 않던) 함수형 프로그래밍의 지평을 열었다.

### 익명클래스
```java
// 42-1 익명클래스의 인스턴스를 함수 객체로 사용
Collections.sort(words, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
});
```
- 익명클래스의 방식은 코드가 너무 길기 때문에 자바는 함수형 프로그래밍에 적합하지 않다.
- 인스턴스를 함수 객체로 사용한다는 말은 `Collections.sort`는 두 객체를 비교해야 하는데, 그 비교 로직을 `Comparator` 인스턴스에 위임한다.
- 즉, 이 익명 클래스의 인스턴스를 함수처럼 사용하는 셈이다.
	- `compare(s1, s2) `호출로 문자열의 길이를 비교하고, 그 결과를 `Collections.sort`가 사용하여 정렬한다.
### 람다
````java
// 42-2 람다식을 함수 객체로 사용
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
````
- 다음은 익명 클래스를 사용한 앞의 코드를 람다 방시긍로 바꾼것이다.
- **타입을 명시해야 코드가 더 명확할 때만 제외하고는, 람다의 모든 매개변수 타입은 생략하자.**
- 상황에 따라 컴파일러가 타입을 결정하지 못할 수 도 있는데 그럴때는 프로그래머가 직접 명시해야 한다.
- 람다 자리에 비교자 생성 메서드를 사용하면 이 코드를 더 간결하게 만들 수 있다 (아이템 14, 43).
```java
Collections.sort(words, comparingInt(String::length));
```
- 더 나아가 자바 8 때 List 인터페이스에 추가된 sort 메서드를 사용하면 더 짧아진다.
```java
words.sort(comparingInt(String::length));
```
- 람다를 이용하면 함수 객체를 실용적으로 사용할 수 있다.

```java
// 42-3 상수별 클래스 몸체와 데이터를 사용한열거 타입
public enum Operation {
    PLUS("+", (x, y) -> x+y);
    MINUS("-", (x,y) -> x-y);
    TIMES("*", (x,y) -> x*y);
    DIVIDE("/", (x,y) -> x / y);
    
    private final String symbol;
    private final DoubleBinaryOperator op;
    
    Operation(String symbol, DoubleBinaryOperator op) {
        this.symbol = symbol;
        this.op = op;
    }
    
    @Override
    public String toString() {
        return symbol;
    }
    
    public double apply(double x, double y) {
        return op.applyAsDouble(x, y);
    }
}
```
- 람다 때문에 클래스 몸체는 더 이상 사용할 이유가 없다고 느낄 지 모르지만 그렇지 않다.  
- **람다는 이름이 없고 문서화도 못한다. 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 사용하지 말아야 한다.**
- 람다는 한줄일때 가장 좋고 세줄 안에 끝내는 것이 좋다.
- 람다는 함수형 인터페이스에서만 쓰인다.
```java
//함수형 인터페이스의 예
Supplier<Double> randomSupplier = () -> Math.random();  
System.out.println(randomSupplier.get());
```
- 추상 클래스의 인스턴스를 만들 때 람다를 쓸 수 없으니, 익명클래스를 써야한다.
- 비슷하게도 추상 메서드가 여러 개인 인터페이스의 인스턴스를 만들 때도 익명 클래스를 쓸 수 있다.
- 마지막으로 람다는 자신을 참조할 수 없다. 람다의 this는 바깥 인스턴스를 가리킨다. 익명 클래스의 this는 익명 클래스 인스턴스 자신이다. 그래서 자신을 참조해야할 경우 익명클래스를 써야 한다.
- 람다도 익명 클래스처럼 직렬화 형태가 구현별로 다를 수 있어, **람다를 직렬화하는 일은 하지 말아야한다.**

## 발표
### 익명 클래스
- 42-1 이 익명클래스의 예제이다.
- 익명클래스 방식은 코드가 길고 가독성이 떨어진다.

### 람다
- 람다는 **함수형 인터페이스의 인스턴스를 더 간결하게 표현하는 방식**입니다.
- 자바 8에서 부터 사용할 수 있게 되었다.
#### 장점
1. 간결하다.(컴파일러가 추론을 해줌)
	- 42-2 코드를 보면 매개변수나 반환값의 타입에 대한 언급이 없다. 컴파일러가 대신 문맥을 살펴 추론해준것이다.
	- **상황에 따라 컴파일러가 타입을 결정 못할때도 있지만 그때는 프로그래머가 직접 명시하면 된다.**
2. 더욱 간결하게도 가능(비교자 생성 메서드)
	- 람다 자리에 비교자 생성 메서드를 사용하면 더 간결하게 만들 수 있다.
3. 함수 객체를 실용적으로 사용가능(별도의 클래스를 만들 필요 없이 함수 자체를 객체처럼 다룰 수 있다)
	- 42-3 -> 42-4 람다를 이용해서 열거 타입 상수의 동작을 구현해 생성자에 넘긴다.
	- 원래 버전보다 간결하고 깔끔해진다.
#### 단점
- 이름이 없고 문서화도 못한다. 
	- 코드 자체로 동작이 명확히 설명되지 않거나 코드가 길면 람다를 쓰지 않아야한다.
	- 3줄이상이면 금지
- 길어지면 가독성이 나빠진다.
- 열거 타입 생성자 안의 람다는 열거 타입의 인스턴스 멤버에 접근할 수 없다.
	- **열거 상수가 초기화될 때 설정되는 인스턴스 멤버에 람다에서 접근하면, 람다의 생성 시점이 열거 상수의 초기화 과정과 겹치면서 아직 초기화되지 않은 멤버를 참조할 가능성이 있으므로 컴파일 오류가 발생할 수 있다.**
#### 참조
 - 람다는 자신을 참조할 수 없음. 람다에서의 this는 키워드 바깥의 인스턴스를 가리킨다.
 - 익명 클래스에서의 this는 익명 클래스의 ㅈ인스턴스 자신을 가리킨다.


