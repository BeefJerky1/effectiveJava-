---
tags:
  - study
  - 이펙티브자바
title: 명명 패턴보다 애너테이션을 사용하라
chapter: 아이템 39
---
## 명명 패턴보다 애너테이션을 사용하라

### 핵심
- 애너테이션으로 할 수 있는 일을 명명 패턴으로 처리할 이유가 없다.
- 자바 프로그래머 라면 예외없이 자바가 제공하는 애너테이션 타입들은 사용해야 한다.
## 명명 패턴
- 기존에는 도구나 프레임워크가 다뤄야할 프로그램 요소에는 딱 구분되는 명명패턴을 적용했었다. ex) JUnit 3까지는 테스트 메서드 이름을 `test`로 반드시 시작해야만 했다.(`testXxxx`)

### 단점
-   오타가 나면 안된다.
    - ex) JUnit3에서 `tsetSafetyOverride`로 지으면 해당 메서드는 무시하고 지나치며, 개발자는 테스트가 통과했다고 생각할 수 있다.
- 올바른 프로그램 요소에서만 사용된다는 보장이 없다.
    - ex) JUnit3에서 메서드가 아닌 클래스 이름을 `TestXxx`와 같이 지어 해당 클래스 내부 메서드를 테스트하고 싶어도, JUnit은 경고 메세지도 없이 해당 클래스 메서드 테스트를 수행하지 않고 넘어간다.
- 프로그램 요소를 매개변수로 전달할 적절한 방법이 없다.
    - 특정 예외를 던져야만 성공하는 테스트가 있을때, 테스트할 방법이 없다.
### 애니테이션
- 애너테이션은 명명패턴의 단점을 모두 해결할 수 있으며, JUnit 4부터 애너테이션을 전면 도입했다.
```java
import java.lang.annotation.*;

/**
 * 테스트 메서드임을 선언
 * 매개변수 없는 정적 메서드 전용
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {
}
```

### 메타 애너테이션
- 애너테이션 선언에 다는 애너테이션
- `@Retention(RetentionPolicy.RUNTIME)` : 런타임시에도 유지되어야 한다.
- `@Target(ElementType.METHOD)` : 반드시 메서드 선언에서면 사용되어야 한다.
###  마커 애너테이션
- 아무 매개변수 없이 단순히 대상에 마킹
- 대상 코드의 의미는 그대로 두고, 그 어노테이션에 관심 있는 도구에서 특별한 처리를 할 수 있게 해준다.
- 실제 클래스에 영향은 주지 않으며, 애너테이션에 관심있는 프로그램에 추가 정보를 제공해준다.
```java
public class AnnotationSample {
    @Test public static void m1() { } //성공
    @Test public static void m2() {   //실패
        throw new RuntimeException("fail");
    }
    /**
     * 정적 메서드가 아님 -> 잘못 적용
     */
    @Test public void m3() { }
    public static void m4(){ }
}
```

## 발표
- 명명패턴은 코드내에서 일관성 있는 이름 규칙을 사용하는 것이다.
- 클래스 이름에 특정 접두사나 접미사를 붙여서 그 역할을 나타내는 방법이다.

### 명명패턴의 문제점
- 오타가 나면 안된다.
- 올바른 프로그램 요소에서만 사용되리라 보증할 방법이 없다.
- 프로그램 요소를 매개변수로 전달할 마땅한 방법이 없다.

### 애너테이션
- 39-1 은 애너테이션의 타입 선언 코드 이다.
- @Test 애너테이션 타입 선언에 다른 애너테이션이 달려있음. 이처럼 애너테이션 선언에 다른 애너테이션을 메타애너테이션이라 한다.
- @Retention
	- @Retention(RetentionPolicy.RUNTIME) 런타임에도 @Test가 유지되어야 한다는 표시
- @Target
	- @Target(ElementType.Method) 메서드 선언에서만 사용되어야 한다고 알려준다.
- 39-2 는 @Test 애너테이션을 실제 적용한 코드

### 마커애너테이션
- 값을 가지지 않는 애너테이션을 말함(매개변수 없이 단순히 대상을 마킹하는 용도)
- 마커 애너테이션은 주로 해당 클래스나 메서드가 특정 용도로 사용됨을 표시
- 타입이나 동작을 나타낸다.
- 39-3은 @Test 애너테이션이 달린 메서드를 찾아 차례대로 호출한다. 그리고 애너테이션이 잘 못 사용해 예외가 발생하면 오류 메세지를 출력한다.
### 매개변수를 받는 애너테이션 타입
- 39-4는 매개변수를 받는 애너테이션 타입 코드이다.
- 이 애너테이션의 매개변수 타입은 `Class<? extends Throwable>` 이며(한정적 타입 토큰), 이는 "_Throwable을 확장한 클래스의 Class 객체_ "라는 뜻이다. 따라서 모든 예외와 오류 타입을 수용한다.
- (P241 하단의 코드)39-3의 코드를 수정했다. 이 코드는 올바른 예외를 던지는지 확인하는데 사용하는 코드가 만들어졌다.
### 배열 매개변수를 받는 애너테이션
- 원소들을 중괄호로 감싸고 쉼표로 구분주기만 하면 여러 매개변수를 넣을 수 있다.
### 다수의 예외를 명시하는 애너테이션 @Repeatable
- 메타 애너테이션을 다는 방식을 선택하여 코드 가독성을 높일 수 있다.
- `@Repeatable`을 단 애너테이션을 반환하는 '컨테이너 애너테이션'을 하나 더 정의하고, `@Repeatable`에 이 컨테이너 애너테이션의 class 객체를 매개변수로 전달해야 한다.
- 컨테이너 애너테이션은 내부 애너테이션 타입의 배열을 반환하는 value 메서드를 정의해야 한다.
- 컨테이너 애너테이션 타입에는 적절한 보존 정책(@Retention)과 적용 대상(@Target)을 명시해야 한다.(그렇지 않으면 컴파일 X)
### 결론
- 명명패턴 쓰지 말고 자바프로그래머라면 예외없이 자바가 제공하는 애너테이션 타입들을 사용하자.
