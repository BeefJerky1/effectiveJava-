---
tags:
  - study
  - 이펙티브자바
title: 프로그램의 동작을 스레드 스케쥴러에 기대지 말라
chapter: 아이템 84
---
## 프로그램의 동작을 스레드 스케쥴러에 기대지 말라

### 핵심
- 프로그램의 동작을 스레드 스케쥴러에 기대지말자. 견고성과 이식성을 모두 해치는 행위다.
- 같은 이유로 `Thread.yield` 와 스레드 우선순위에 의존해서도 안된다. 이 기능들은 스레드 스케쥴러에 제공하는 힌트일 뿐이다. 스레드 우선순위는 이미 잘 동작하는 프로그램의 서비스 품질을 높이기 위해 드물게 쓰일 수는 있지만, 간신히 동작하는 프로그램을 '고치는 용도'로 사용해서는 안된다.

### 스레드 스케쥴러
- 여러 스레드가 실행중이면 운영체제의 스레드 스케쥴러가 어떤 스레드를 얼마나 오래 실행할지 정한다.
- 스케쥴러 정책은 운영체제마다 다를 수 있다.
- 정확성이나 성능이 스레드 스케쥴러에 따라 달라지는 프로그램이라면 다른 플랫폼에 이식하기 어렵다.
### 좋은 프로그램 작성하는 방법
- 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 한다.
	- 스레드가 고민한 거리가 줄어든다.
- 실행가능한 스레드의 수와 전체 스레드의  수는 구분해야한다.

### 실행가능한 스레드 수를 적게 유지하는 방법
- 각 스레드가 무언가 유용한 작업을 완료한 후에는 다음일거리가 생길때까지 대기하도록 하는 것
- 당장 처리해야할 작업이 없다면 실행돼서는 안된다.
- 스레드 풀 크기를 적절히 설정하고 작업은 짧게 유지하면 된다. 단, 너무 짧으면 작업을 분배하는 부담이 오히려 성능을 떨어뜨릴 수 있다.

### 바쁜 대기
- 스레드는 절대 바쁜 대기 상태가 되면 안된다.
- 바쁜대기는 스레드 스케쥴러의 변덕에 취약할 뿐 아니라, 프로세서에 큰 부담을 주어 다른 작업이 실행될 기회를 박탈한다.
```java
public class BusyWaitExample {
    private static volatile boolean ready = false;
    public static void main(String[] args) {
        Thread worker = new Thread(() -> {
            while (!ready) {
                // 🔴 바쁜 대기: 계속해서 `ready` 변수를 체크 (CPU 낭비)
            }
            System.out.println("Worker 스레드 시작!");
        });
        worker.start();
        try {
            Thread.sleep(2000); // 메인 스레드가 2초 후 ready를 true로 변경
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        ready = true; // Worker 스레드가 실행될 조건 충족
    }
}
```
- 위의 코드가 대표적인 예이다.
- `ready` 변수가 `true` 가 될때까지 `CPU`를 계속사용하여 쉬지 않고 반복문을 실행한다.

### yield 메서드
- 특정스레드가 다른 스레드들과 비교해 CPU 시간을 충분히 얻지 못해서 간신히 돌아가는 프로그램을 보더라도 `Thread.yield` 를 써서 문제를 고치려고 하지말자.
- 차라리 애플리케이션 구조를 바꿔 동시에 실행 가능한 스레드 수가 적어지도록 조치해주자.
- 스레드 우선순위는 자바에서 이식성이 가장 나쁜 특성에 속한다.

### JVM 스케쥴러
- 운영체제의 스케쥴러에 의해 동작하며 여러 스레드를 어떻게 실행할지 관리하는 역할을 함
- 스레드 우선순위를 설정할 수 있지만 OS가 이를 반드시 반영하지 는 않는다.
- JVM 자체가 스레드 스케쥴링을 하지 않고 OS가 결정한다.
- Thread.yield() 거의 의미 없음
- Thread.sleep() 은 정확한 타이밍을 보장하지 않음
- Thread.join() 은 스레드의 실행을 멈추고 다른 스레드가 끝날때까지 기다림
	- 한지만 OS의 스케쥴링 정책에 따라 예상보다 오래 걸릴 수 있음

### JVM 쓰레드 상태
- new
	- start() 메서드를 통해 동작시키게 되면 JVM 스레드 스케쥴링 대상이 되며 runnable 상태가 됨.
	- 한번 new 상태로 돌입한 스레드는 다시 new 상태가 될 수 없다.
- runnable
	- runnable 큐에 대기하며 우선순위에 따라 running 상태로 만들어 스레드가 동작된다.
- running
	- run() 메서드가 호출된다. 
	- run() 메서들 실행후 종료되면 terminate 상태가 된다.
	- sleep(), join() 메서드 등을 사용하면 waiting pool 로 이동하고 대기한다.
	- yield() 메서드가 수행되면 다시 runnable 상태로 옮긴다.
- waiting
	- sleep(), join() 메서드에 의해 waiting pool 로 와서 대기. 대기 조건이 끝나거나 인터럽트가 발생하면 다시 runnable 큐로 이동된다.
- terminate
	- run() 메서드 수행이 끝나면 terminate 상태로 스레드가 종료된다.
	- 한번 terminate 된 스레드 객체는 다시 start()를 호출하여 스케쥴링에 포함시킬수 없다.
### 우선순위를 보장하는 방법
- Thread.setPriority() -> os 마다 동작이 다름
- priorityBlockingQueue 사용 -> 실제로 우선순위를 보장하려면 큐를 사용해서 작업을 정렬해야함.