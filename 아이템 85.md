---
tags:
  - study
  - 이펙티브자바
title: 자바 직렬화의 대안을 찾으라
chapter: 아이템 85
---
## 자바 직렬화의 대안을 찾으라
### 핵심
- 직렬화는 위험하니 피해야 한다. 시스템을 밑바닥부터 설계한다면 JSON 이나 프로토콜 버퍼같은 대안을 사용하자. 신뢰할 수 없는 데이터는 역직렬화하지 말자. 꼭 해야한다면 객체 역직렬화 필터링을 사용하되, 이마저도 모든 공격을 막아줄 수는 없음을 기억하자.
- 클래스가 직렬화를 지원하도록 만들지 말고, 꼭 그렇게 만들어야 한다면 정말 신경써서 작성해야 한다.

### 직렬화
- 객체를 바이트 스트림으로 변환하여 저장하거나 전송할 수 있도록 하는 과정.
- 반대로 바이트스트림을 다시 객체로 변환하는 과정을 역직렬화라고 한다.

### 자바의 직렬화
- 자바의 직렬화는 위험하다.
- 직렬화의 근본적인 문제는 공격 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다는 점이다.
- 자바의 표준 라이브러리나 아파치 커먼스 컬렉션 같은 서드파티 라이브러리는 물론 애플리케이션 자신의 클래스들도 공격 범위에 포함된다.

### 가젯
- 자바 라이브러리와 널리 쓰이는 서드파티 라이브러리에서 직결화 가능 타입들을 연구하여 역직렬화 과정에서 잠재적으로 위험한 동작을 수행하는 메서드들을 가젯이라고 부른다.
- 여러 가젯을 함께 사용하여 가젯 체인을 구성할 수도 있는데 공격자가 하드웨어의 네이티브 코드를 마음대로 실행할 수 있는 강력한 가젯 체인도 발견되곤한다.
### 스트림
- 역직렬화에 시간이 오래 걸리는 짧은 스트림을 역직렬화 하는 것만으로도 서비스 거부 공격에 쉽게 노출된다. 이런 스트림을 역직렬화 폭탄이라고 한다.
```java
public class DeserializationBomb {
    public static void main(String[] args) throws Exception {
        System.out.println(bomb().length);
        deserialize(bomb());
    }

    static byte[] bomb() {
        Set<Object> root = new HashSet<>();
        Set<Object> s1 = root;
        Set<Object> s2 = new HashSet<>();
        for (int i = 0; i < 100; i++) {
            Set<Object> t1 = new HashSet<>();
            Set<Object> t2 = new HashSet<>();
            t1.add("foo"); // make it not equal to t2
            s1.add(t1);
            s1.add(t2);
            s2.add(t1);
            s2.add(t2);
            s1 = t1;
            s2 = t2;
        }
        return serialize(root);
    }
}
```
- 재귀적인 데이터 구조를 생성
	- `Set<Object>`을 중첩적으로 서로 참조하게 구성하면서 `root`가 포함하는 객체 개수가 기하급수적으로 증가한다.
- 객체 수가 폭발적으로 증가
	- `bomb()` 메서드는 100번의 루프를 돌면서 중첩된 `Set<Object>`을 계속 생성한다.
	- 결과적으로 `root`는 엄청나게 많은 객체를 포함하게 된다.
- 직렬화시 엄청난 데이터 크기
	- `serialize(root)`를 실행할 때, `ObjectOutputStream`은 `root` 내부의 **모든 객체를 순회하면서 직렬화**한다.
	- `root` 내부의 데이터 구조가 너무 크기 때문에 **`CPU` 사용량과 메모리 사용량이 폭발적으로 증가**한다.
	- 결국, **`JVM`의 `GC`(가비지 컬렉터)가 과부하되거나 `OutOfMemoryError`가 발생**할 수도 있다.
- 역직렬화시 더 큰 문제 발생
	- `deserialize(bomb())` 호출 시, `ObjectInputStream`이 전체 데이터를 역직렬화하면서 **매우 오랜 시간이 소요되거나 무한 루프에 빠질 수 있음**.
	- 만약 네트워크를 통해 전달되는 데이터라면, 서버가 공격당할 위험이 있음.
- 직렬화 시, **O(2^n) 수준의 연산이 필요**하게 됨.
- **직렬화 위험을 회피하는 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.**
- **마찬가지로, 작성하는 새로운 시스템에서 자바 직렬화를 써야할 이유는 거의 없다.**

### 크로스-플랫폼 구조화된 데이터 표현
- 자바의 직렬화보다 간단하다.
- 임의 객체 그래프를 자동으로 직렬화/역직렬화하지 않고, 속성-값 쌍의 집합으로 구성된 간단하고 구조화된 데이터 객체를 사용한다.
- 기본 타입 몇 개와 배열 타입만 지원한다.
- 이러한 간단한 추상화만으로 강력한 분산 시스템을 구축하기에 충분하고, 자바 직렬화의 문제를 회피할 수 있다.
- **대표적인 예로는 JSON과 프로토콜 버퍼이다.**
- **JSON**
    - 브라우저와 서버의 통신용으로 설계됐으며, 자바스크립트용으로 만들어졌다.
    - 텍스트 기반이라 사람이 읽을 수 있다.
    - 오직 데이터를 표현하는 데만 쓰인다.
- **프로토콜 버퍼**
    - 구글이 서버 사이에 데이터를 교환하고 저장하기 위해 설계됐으며, C++용으로 만들어졌다.
    - 이진 표현이라 효율이 훨씬 높다
    - 문서를 위한 스키마(타입)를 제공하고 올바로 쓰도록 강요한다.
    - 이진 표현 뿐만 아니라 사람이 읽을 수 있는 텍스트 표현도 지원한다.